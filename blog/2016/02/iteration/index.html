<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>Multidimensional algorithms and iteration</title>
<meta name="author" content="Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al." />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="Official website for the Julia programming language. Join the Julia community today.">

<meta property="og:title" content="The Julia Language"/>
<meta property="og:image" content="http://www.julialang.org/images/julia-open-graph.png"/>
<meta property="og:description" content="Official website for the Julia programming language"/>

<link href="https://fonts.googleapis.com/css?family=Roboto:400,400i,500,500i,700,700i" rel="stylesheet">
<link rel="stylesheet" href="https://julialang.org/v2/css/bootstrap.min.css" />
<link rel="stylesheet" href="https://julialang.org/v2/css/app.css" />
<link rel="stylesheet" href="https://julialang.org/v2/css/fonts.css" />

<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$','$'], ['\\(','\\)']],
      displayMath: [['$$','$$']],
      processEscapes: true,
      processEnvironments: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      TeX: { equationNumbers: { autoNumber: "AMS" },
             extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
  });
</script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-28835595-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  

  
</head>

<body>
  
  

<div class="container py-3 py-lg-0">
  <nav class="navbar navbar-expand-lg navbar-light bg-light" id="main-menu">

    <a class="navbar-brand" href="../../../../" id="logo">
      <img src="https://julialang.org/v2/img/logo.svg" height="55" width="85" alt="JuliaLang Logo"/>
    </a>

    <button class="navbar-toggler ml-auto hidden-sm-up float-xs-left" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav mr-auto">
        
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="https://julialang.org/downloads/">Download</a>
        </li>
        <li class="nav-item flex-md-fill text-md-center">
          <a class="nav-link" href="https://docs.julialang.org">Documentation</a>
        </li>
        <li class="nav-item  active  flex-md-fill text-md-center">
          <a class="nav-link" href="https://julialang.org/blog/">Blog</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="https://julialang.org/community/">Community</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="https://julialang.org/learning/">Learning</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="https://julialang.org/research/">Research</a>
        </li>
        <li class="nav-item  flex-md-fill text-md-center">
          <a class="nav-link" href="https://julialang.org/jsoc/">JSoC</a>
        </li>
        <li class="nav-item donate flex-md-fill text-md-center">
          <a class="btn btn-success" href="https://numfocus.org/donate-to-julia">Donate</a>
        </li>
      </ul>
    </div>

  </nav>
</div>



  <br /><br />

  <div class="container">

  <div id="blogpost">
    <h1>Multidimensional algorithms and iteration</h1>

    <p class="metadata">
      <span class="timestamp">01 February, 2016</span>
      
      &nbsp;|&nbsp;
      <span class="author"><a href="http://holylab.wustl.edu">Tim Holy</a></span>
      
    </p>

    

<p><strong>Note: updated December 2018 for Julia 1.1</strong></p>

<p>Julia makes it easy to write elegant and
efficient multidimensional algorithms. The new capabilities rest on
two foundations: an iterator called <code>CartesianIndices</code>, and
sophisticated array indexing mechanisms.  Before I explain, let me
emphasize that developing these capabilities was a collaborative
effort, with the bulk of the work done by Matt Bauman (@mbauman),
Jutho Haegeman (@Jutho), and myself (@timholy).</p>

<p>These iterators are deceptively simple, so much so that I&rsquo;ve never
been entirely convinced that this blog post is necessary: once you
learn a few principles, there&rsquo;s almost nothing to it.  However, like
many simple concepts, the implications can take a while to sink in.
It&rsquo;s also possible to confuse these techniques with
<a href="https://docs.julialang.org/en/latest/devdocs/cartesian/"><code>Base.Cartesian</code></a>,
which is a completely different (and more painful) approach to
solving the same problem.  There are still a few occasions where
<code>Base.Cartesian</code> is helpful or necessary, but for many problems these new
capabilities represent a vastly simplified approach.</p>

<p>Let&rsquo;s introduce these iterators with an extension of an example taken
from the
<a href="https://docs.julialang.org/en/v1/manual/arrays/#Iteration-1">manual</a>.</p>

<h1 id="eachindex-cartesianindex-and-cartesianindices">eachindex, CartesianIndex, and CartesianIndices</h1>

<p>You may already know that there are two recommended
ways to iterate over the elements in an <code>AbstractArray</code>: if you don&rsquo;t
need an index associated with each element, then you can use</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">for</span> a<span style="color:#666"></span> <span style="color:#a2f">in</span> A<span style="color:#666"></span>    <span style="color:#080;font-style:italic"># A is an AbstractArray</span>
    <span style="color:#080;font-style:italic"># Code that does something with the element a</span>
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>If instead you also need the index, then use</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">for</span> i<span style="color:#666"></span> <span style="color:#a2f">in</span> eachindex<span style="color:#666"></span>(A<span style="color:#666"></span>)
    <span style="color:#080;font-style:italic"># Code that does something with i and/or A[i]</span>
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>In some cases, the first line of this loop expands to <code>for i =
1:length(A)</code>, and <code>i</code> is just an integer.  However, in other cases,
this will expand to the equivalent of</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">for</span> i<span style="color:#666"></span> <span style="color:#a2f">in</span> CartesianIndices<span style="color:#666"></span>(A<span style="color:#666"></span>)
    <span style="color:#080;font-style:italic"># i is now a CartesianIndex</span>
    <span style="color:#080;font-style:italic"># Code that does something with i and/or A[i]</span>
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>Let&rsquo;s see what these objects are:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">julia<span style="color:#666"></span><span style="color:#666">&gt;</span> A<span style="color:#666"></span> <span style="color:#666">=</span> rand<span style="color:#666"></span>(<span style="color:#666">3</span>,<span style="color:#666">2</span>)

julia<span style="color:#666"></span><span style="color:#666">&gt;</span> <span style="color:#a2f;font-weight:bold">for</span> i<span style="color:#666"></span> <span style="color:#a2f">in</span> CartesianIndices<span style="color:#666"></span>(A<span style="color:#666"></span>)
          <span style="color:#a2f">@show</span><span style="color:#666"></span> i<span style="color:#666"></span>
       <span style="color:#a2f;font-weight:bold">end</span>
i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">1</span>, <span style="color:#666">1</span>)
i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">1</span>)
i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">1</span>)
i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">1</span>, <span style="color:#666">2</span>)
i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">2</span>)
i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">2</span>)</code></pre></div>

<p>A <code>CartesianIndex{N}</code> represents an <code>N</code>-dimensional index.
<code>CartesianIndex</code>es are based on tuples, and indeed you can access the
underlying tuple with <code>Tuple(i)</code>.</p>

<p>A <code>CartesianIndices</code> acts like an array of <code>CartesianIndex</code> values:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">julia<span style="color:#666"></span><span style="color:#666">&gt;</span> iter<span style="color:#666"></span> <span style="color:#666">=</span> CartesianIndices<span style="color:#666"></span>(A<span style="color:#666"></span>)
<span style="color:#666">3</span>×2<span style="color:#666"></span> CartesianIndices<span style="color:#666"></span>{<span style="color:#666">2</span>,<span style="color:#0b0;font-weight:bold">Tuple</span>{Base<span style="color:#666"></span><span style="color:#666">.</span>OneTo<span style="color:#666"></span>{<span style="color:#0b0;font-weight:bold">Int64</span>},Base<span style="color:#666"></span><span style="color:#666">.</span>OneTo<span style="color:#666"></span>{<span style="color:#0b0;font-weight:bold">Int64</span>}}}<span style="color:#666">:</span>
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">1</span>, <span style="color:#666">1</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">1</span>, <span style="color:#666">2</span>)
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">1</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">2</span>)
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">1</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">2</span>)

julia<span style="color:#666"></span><span style="color:#666">&gt;</span> supertype<span style="color:#666"></span>(typeof<span style="color:#666"></span>(iter<span style="color:#666"></span>))
<span style="color:#0b0;font-weight:bold">AbstractArray</span>{<span style="color:#0b0;font-weight:bold">CartesianIndex</span>{<span style="color:#666">2</span>},<span style="color:#666">2</span>}</code></pre></div>

<p>As a consequence <code>iter[2,2]</code> and <code>iter[5]</code> both return <code>CartesianIndex(2, 2)</code>; indeed,
the latter is the recommended way to convert
from a <a href="https://docs.julialang.org/en/latest/devdocs/subarrays/#Indexing:-cartesian-vs.-linear-indexing-1">linear index</a> to a multidimensional cartesian index.</p>

<p>However, internally <code>iter</code> is just a wrapper around the <code>axes</code> range for each dimension:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">julia<span style="color:#666"></span><span style="color:#666">&gt;</span> iter<span style="color:#666"></span><span style="color:#666">.</span>indices<span style="color:#666"></span>
(Base<span style="color:#666"></span><span style="color:#666">.</span>OneTo<span style="color:#666"></span>(<span style="color:#666">3</span>), Base<span style="color:#666"></span><span style="color:#666">.</span>OneTo<span style="color:#666"></span>(<span style="color:#666">2</span>))</code></pre></div>

<p>As a consequence, in many applications the creation and usage of these objects has
little or no overhead.</p>

<p>You can construct these manually: for example,</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">julia<span style="color:#666"></span><span style="color:#666">&gt;</span> CartesianIndices<span style="color:#666"></span>((<span style="color:#666">-</span><span style="color:#666">7</span><span style="color:#666">:</span><span style="color:#666">7</span>, <span style="color:#666">0</span><span style="color:#666">:</span><span style="color:#666">15</span>))
<span style="color:#666">15</span>×16<span style="color:#666"></span> CartesianIndices<span style="color:#666"></span>{<span style="color:#666">2</span>,<span style="color:#0b0;font-weight:bold">Tuple</span>{<span style="color:#0b0;font-weight:bold">UnitRange</span>{<span style="color:#0b0;font-weight:bold">Int64</span>},<span style="color:#0b0;font-weight:bold">UnitRange</span>{<span style="color:#0b0;font-weight:bold">Int64</span>}}}<span style="color:#666">:</span>
<span style="color:#080;font-style:italic"># remaining output suppressed</span></code></pre></div>

<p>corresponds to an iterator that will loop over <code>-7:7</code> along the first
dimension and <code>0:15</code> along the second.</p>

<p>One reason that <code>eachindex</code> is recommended over <code>for i = 1:length(A)</code>
is that some <code>AbstractArray</code>s cannot be indexed efficiently with a
linear index; in contrast, a much wider class of objects can be
efficiently indexed with a multidimensional iterator.  (SubArrays are,
generally speaking, <a href="https://docs.julialang.org/en/v1/devdocs/subarrays">a prime
example</a>.)
<code>eachindex</code> is designed to pick the most efficient iterator for the
given array type.  You can even use</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">for</span> i<span style="color:#666"></span> <span style="color:#a2f">in</span> eachindex<span style="color:#666"></span>(A<span style="color:#666"></span>, B<span style="color:#666"></span>)
    <span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span></code></pre></div>

<p>to increase the likelihood that <code>i</code> will be efficient for accessing
both <code>A</code> and <code>B</code>.  (A second reason to use <code>eachindex</code> is that some arrays
don&rsquo;t starting indexing at 1, but that&rsquo;s a topic for a separate
<a href="https://julialang.org/blog/2017/04/offset-arrays">blog post</a>.)</p>

<p>As we&rsquo;ll see below, these iterators have another purpose: independent
of whether the underlying arrays have efficient linear indexing,
multidimensional iteration can be a powerful ally when writing
algorithms.  The rest of this blog post will focus on this
latter application.</p>

<h1 id="writing-multidimensional-algorithms-with-cartesianindex-iterators">Writing multidimensional algorithms with CartesianIndex iterators</h1>

<h2 id="a-multidimensional-boxcar-filter">A multidimensional boxcar filter</h2>

<p>Let&rsquo;s suppose we have a multidimensional array <code>A</code>, and we want to
compute the <a href="https://en.wikipedia.org/wiki/Boxcar_averager">&ldquo;moving
average&rdquo;</a> over a
3-by-3-by-&hellip; block around each element.  From any given index position,
we&rsquo;ll want to sum over a region offset by <code>-1:1</code> along each dimension.
Edge positions have to be treated specially, of course, to avoid going
beyond the bounds of the array.</p>

<p>In many languages, writing a general (N-dimensional) implementation of
this conceptually-simple algorithm is somewhat painful, but in Julia
it&rsquo;s a piece of cake:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">function</span> boxcar3<span style="color:#666"></span>(A<span style="color:#666"></span><span style="color:#666">:</span><span style="color:#666">:</span><span style="color:#0b0;font-weight:bold">AbstractArray</span>)
    out<span style="color:#666"></span> <span style="color:#666">=</span> similar<span style="color:#666"></span>(A<span style="color:#666"></span>)
    R<span style="color:#666"></span> <span style="color:#666">=</span> CartesianIndices<span style="color:#666"></span>(A<span style="color:#666"></span>)
    Ifirst<span style="color:#666"></span>, Ilast<span style="color:#666"></span> <span style="color:#666">=</span> first<span style="color:#666"></span>(R<span style="color:#666"></span>), last<span style="color:#666"></span>(R<span style="color:#666"></span>)
    I1<span style="color:#666"></span> <span style="color:#666">=</span> oneunit<span style="color:#666"></span>(Ifirst<span style="color:#666"></span>)
    <span style="color:#a2f;font-weight:bold">for</span> <span style="color:#a2f">I</span> <span style="color:#a2f">in</span> R<span style="color:#666"></span>
        n<span style="color:#666"></span>, s<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#666">0</span>, zero<span style="color:#666"></span>(eltype<span style="color:#666"></span>(out<span style="color:#666"></span>))
        <span style="color:#a2f;font-weight:bold">for</span> J<span style="color:#666"></span> <span style="color:#a2f">in</span> max<span style="color:#666"></span>(Ifirst<span style="color:#666"></span>, <span style="color:#a2f">I</span><span style="color:#666">-</span>I1<span style="color:#666"></span>)<span style="color:#666">:</span>min<span style="color:#666"></span>(Ilast<span style="color:#666"></span>, <span style="color:#a2f">I</span><span style="color:#666">+</span>I1<span style="color:#666"></span>)
            s<span style="color:#666"></span> <span style="color:#666">+=</span> A<span style="color:#666"></span>[J<span style="color:#666"></span>]
            n<span style="color:#666"></span> <span style="color:#666">+=</span> <span style="color:#666">1</span>
        <span style="color:#a2f;font-weight:bold">end</span>
        out<span style="color:#666"></span>[<span style="color:#a2f">I</span>] <span style="color:#666">=</span> s<span style="color:#666"></span><span style="color:#666">/</span>n<span style="color:#666"></span>
    <span style="color:#a2f;font-weight:bold">end</span>
    out<span style="color:#666"></span>
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>(Note that this example is only for Julia versions 1.1 and higher.)</p>

<p>Let&rsquo;s walk through this line by line:</p>

<ul>
<li><p><code>out = similar(A)</code> allocates the output. In a &ldquo;real&rdquo; implementation,
you&rsquo;d want to be a little more careful about the element type of the
output (what if the input array element type is <code>Int</code>?), but
we&rsquo;re cutting a few corners here for simplicity.</p></li>

<li><p><code>R = CartesianIndices(A)</code> creates the iterator for the array. Assuming <code>A</code>
starts indexing at 1, this ranges from <code>CartesianIndex(1, 1, 1, ...)</code> to
<code>CartesianIndex(size(A,1), size(A,2), size(A,3), ...)</code>.  We don&rsquo;t
use <code>eachindex</code>, because we can&rsquo;t be sure whether that will return a
<code>CartesianIndices</code> iterator, and here we explicitly need one.</p></li>

<li><p><code>Ifirst = first(R)</code> and <code>Ilast = last(R)</code> return the lower
(<code>CartesianIndex(1, 1, 1, ...)</code>) and upper
(<code>CartesianIndex(size(A,1), size(A,2), size(A,3), ...)</code>) bounds
of the iteration range, respectively.  We&rsquo;ll use these to ensure
that we never access out-of-bounds elements of <code>A</code>.</p></li>

<li><p><code>I1 = oneunit(Ifirst)</code> creates an all-1s <code>CartesianIndex</code> with the same
dimensionality as <code>Ifirst</code>. We&rsquo;ll use this in arithmetic operations to
define a region-of-interest.</p></li>

<li><p><code>for I in R</code>: here we loop over each entry of <code>R</code>, corresponding to both
<code>A</code> and <code>out</code>.</p></li>

<li><p><code>n = 0</code> and <code>s = zero(eltype(out))</code> initialize the accumulators. <code>s</code>
will hold the sum of neighboring values. <code>n</code> will hold the number of
neighbors used; in most cases, after the loop we&rsquo;ll have <code>n == 3^N</code>,
but for edge points the number of valid neighbors will be smaller.</p></li>

<li><p><code>for J in max(Ifirst, I-I1):min(Ilast, I+I1)</code> is
probably the most &ldquo;clever&rdquo; line in the algorithm.  <code>I-I1</code> is a
<code>CartesianIndex</code> that is lower by 1 along each dimension, and <code>I+I1</code>
is higher by 1.
However, when <code>I</code> represents an edge point, either <code>I-I1</code> or <code>I+I1</code>
(or both) might be out-of-bounds.  <code>max(Ifirst, I-I1)</code> ensures that each
coordinate of <code>J</code> is 1 or larger, while <code>min(Ilast, I+I1)</code> ensures
that <code>J[d] &lt;= size(A,d)</code>.</p></li>
</ul>

<p>Putting these two together with a colon, <code>Ilower:Iupper</code>,
  creates a <code>CartesianIndices</code> object that serves as an iterator.</p>

<ul>
<li><p>The inner loop accumulates the sum in <code>s</code> and the number of visited
neighbors in <code>n</code>.</p></li>

<li><p>Finally, we store the average value in <code>out[I]</code>.</p></li>
</ul>

<p>Not only is this implementation simple, it is also surprisingly robust:
for edge points it computes the average of whatever nearest-neighbors
it has available.  It even works if <code>size(A, d) &lt; 3</code> for some
dimension <code>d</code>; we don&rsquo;t need any error checking on the size of <code>A</code>.</p>

<h2 id="computing-a-reduction">Computing a reduction</h2>

<p>For a second example, consider the implementation of multidimensional
<em>reductions</em>. A reduction takes an input array, and returns an array
(or scalar) of smaller size.  A classic example would be summing along
particular dimensions of an array: given a three-dimensional array,
you might want to compute the sum along dimension 2, leaving
dimensions 1 and 3 intact.</p>

<h3 id="the-core-algorithm">The core algorithm</h3>

<p>An efficient way to write this algorithm requires that the output
array, <code>B</code>, is pre-allocated by the caller (later we&rsquo;ll see how one
might go about allocating <code>B</code> programmatically).  For example, if the
input <code>A</code> is of size <code>(l,m,n)</code>, then when summing along just dimension
2 the output <code>B</code> would have size <code>(l,1,n)</code>.</p>

<p>Given this setup, the implementation is shockingly simple:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">function</span> sumalongdims!<span style="color:#666"></span>(B<span style="color:#666"></span>, A<span style="color:#666"></span>)
    <span style="color:#080;font-style:italic"># It&#39;s assumed that B has size 1 along any dimension that we&#39;re summing,</span>
    <span style="color:#080;font-style:italic"># and otherwise matches A</span>
    fill!<span style="color:#666"></span>(B<span style="color:#666"></span>, <span style="color:#666">0</span>)
    Bmax<span style="color:#666"></span> <span style="color:#666">=</span> last<span style="color:#666"></span>(CartesianIndices<span style="color:#666"></span>(B<span style="color:#666"></span>))
    <span style="color:#a2f;font-weight:bold">for</span> <span style="color:#a2f">I</span> <span style="color:#a2f">in</span> CartesianIndices<span style="color:#666"></span>(A<span style="color:#666"></span>)
        B<span style="color:#666"></span>[min<span style="color:#666"></span>(Bmax<span style="color:#666"></span>,<span style="color:#a2f">I</span>)] <span style="color:#666">+=</span> A<span style="color:#666"></span>[<span style="color:#a2f">I</span>]
    <span style="color:#a2f;font-weight:bold">end</span>
    B<span style="color:#666"></span>
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>The key idea behind this algorithm is encapsulated in the single
statement <code>B[min(Bmax,I)]</code>.  For our three-dimensional example where
<code>A</code> is of size <code>(l,m,n)</code> and <code>B</code> is of size <code>(l,1,n)</code>, the inner loop
is essentially equivalent to</p>
<pre><code>B[i,1,k] += A[i,j,k]</code></pre>
<p>because <code>min(1,j) = 1</code>.</p>

<h3 id="the-wrapper-and-handling-type-instability-using-function-barriers">The wrapper, and handling type-instability using function barriers</h3>

<p>As a user, you might prefer an interface more like <code>sumalongdims(A,
dims)</code> where <code>dims</code> specifies the dimensions you want to sum along.
<code>dims</code> might be a single integer, like <code>2</code> in our example above, or
(should you want to sum along multiple dimensions at once) a tuple or
<code>Vector{Int}</code>.  This is indeed the interface used in <code>sum(A; dims=dims)</code>;
here we want to write our own (somewhat simpler) implementation.</p>

<p>One possible bare-bones implementation of the wrapper looks like this:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">function</span> sumalongdims<span style="color:#666"></span>(A<span style="color:#666"></span>, dims<span style="color:#666"></span>)
    sz<span style="color:#666"></span> <span style="color:#666">=</span> [size<span style="color:#666"></span>(A<span style="color:#666"></span>)<span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>]
    sz<span style="color:#666"></span>[[dims<span style="color:#666"></span><span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>]] <span style="color:#666">.=</span> <span style="color:#666">1</span>
    B<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">Array</span>{eltype<span style="color:#666"></span>(A<span style="color:#666"></span>)}(undef<span style="color:#666"></span>, sz<span style="color:#666"></span><span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>)
    sumalongdims!<span style="color:#666"></span>(B<span style="color:#666"></span>, A<span style="color:#666"></span>)
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>Obviously, this simple implementation skips all relevant error
checking.  However, here the main point I wish to explore is that the
allocation of <code>B</code> turns out to be
<a href="https://docs.julialang.org/en/latest/manual/faq/#man-type-stability-1">non-inferrable</a>:
<code>sz</code> is a <code>Vector{Int}</code>, the length (number of elements) of a specific
<code>Vector{Int}</code> is not encoded by the type itself, and therefore the
dimensionality of <code>B</code> cannot be inferred.</p>

<p>Now, we could fix that in several ways, for example by annotating the
result:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">B<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">Array</span>{eltype<span style="color:#666"></span>(A<span style="color:#666"></span>)}(undef<span style="color:#666"></span>, sz<span style="color:#666"></span><span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>)<span style="color:#666">:</span><span style="color:#666">:</span><span style="color:#0b0;font-weight:bold">Array</span>{eltype<span style="color:#666"></span>(A<span style="color:#666"></span>),ndims<span style="color:#666"></span>(A<span style="color:#666"></span>)}</code></pre></div>

<p>or by using an implementation that <em>is</em> inferrable:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">function</span> sumalongdims<span style="color:#666"></span>(A<span style="color:#666"></span>, dims<span style="color:#666"></span>)
    sz<span style="color:#666"></span> <span style="color:#666">=</span> ntuple<span style="color:#666"></span>(i<span style="color:#666"></span><span style="color:#666">-</span><span style="color:#666">&gt;</span>i<span style="color:#666"></span> <span style="color:#666">∈</span> dims<span style="color:#666"></span> <span style="color:#666">?</span> <span style="color:#666">1</span> <span style="color:#666">:</span> size<span style="color:#666"></span>(A<span style="color:#666"></span>, i<span style="color:#666"></span>), <span style="color:#0b0;font-weight:bold">Val</span>(ndims<span style="color:#666"></span>(A<span style="color:#666"></span>)))
    B<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">Array</span>{eltype<span style="color:#666"></span>(A<span style="color:#666"></span>)}(undef<span style="color:#666"></span>, sz<span style="color:#666"></span><span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>)
    sumalongdims!<span style="color:#666"></span>(B<span style="color:#666"></span>, A<span style="color:#666"></span>)
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>However, here we want to emphasize that this design&mdash;having a separate
<code>sumalongdims!</code> from <code>sumalongdims</code>&mdash;often mitigates the worst aspects
of inference problems. This trick, using a <a href="https://docs.julialang.org/en/v1/manual/performance-tips/#kernel-functions-1">function-call to separate a
performance-critical step from a potentially type-unstable
precursor</a>,
is sometimes referred to as introducing a <em>function barrier</em>.
It allows Julia&rsquo;s compiler to generate a well-optimized version of
<code>sumalongdims!</code> even if the intermediate type of <code>B</code> is not known.</p>

<p>As a general rule, when writing multidimensional code you should
ensure that the main iteration is in a separate function from
type-unstable precursors.  (In older versions of Julia, you might see
kernel functions annotated with <code>@noinline</code> to prevent the
inliner from combining the two back together, but for more recent
versions of Julia this should no longer be necessary.)</p>

<p>Of course, in this example there&rsquo;s a second motivation for making this
a standalone function: if this calculation is one you&rsquo;re going to
repeat many times, re-using the same output array can reduce the
amount of memory allocation in your code.</p>

<h2 id="filtering-along-a-specified-dimension-exploiting-multiple-indexes">Filtering along a specified dimension (exploiting multiple indexes)</h2>

<p>One final example illustrates an important new point: when you index
an array, you can freely mix <code>CartesianIndex</code>es and
integers.  To illustrate this, we&rsquo;ll write an <a href="https://en.wikipedia.org/wiki/Exponential_smoothing">exponential
smoothing
filter</a>.  An
efficient way to implement such filters is to have the smoothed output
value <code>s[i]</code> depend on a combination of the current input <code>x[i]</code> and
the previous filtered value <code>s[i-1]</code>; in one dimension, you can write
this as</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">function</span> expfilt1!<span style="color:#666"></span>(s<span style="color:#666"></span>, x<span style="color:#666"></span>, α<span style="color:#666"></span>)
    <span style="color:#666">0</span> <span style="color:#666">&lt;</span> α<span style="color:#666"></span> <span style="color:#666">&lt;</span><span style="color:#666">=</span> <span style="color:#666">1</span> <span style="color:#666">||</span> error<span style="color:#666"></span>(<span style="color:#b44">&#34;</span><span style="color:#b44">α</span><span style="color:#b44"> </span><span style="color:#b44">m</span><span style="color:#b44">u</span><span style="color:#b44">s</span><span style="color:#b44">t</span><span style="color:#b44"> </span><span style="color:#b44">b</span><span style="color:#b44">e</span><span style="color:#b44"> </span><span style="color:#b44">b</span><span style="color:#b44">e</span><span style="color:#b44">t</span><span style="color:#b44">w</span><span style="color:#b44">e</span><span style="color:#b44">e</span><span style="color:#b44">n</span><span style="color:#b44"> </span><span style="color:#b44">0</span><span style="color:#b44"> </span><span style="color:#b44">a</span><span style="color:#b44">n</span><span style="color:#b44">d</span><span style="color:#b44"> </span><span style="color:#b44">1</span><span style="color:#b44">&#34;</span>)
    s<span style="color:#666"></span>[<span style="color:#666">1</span>] <span style="color:#666">=</span> x<span style="color:#666"></span>[<span style="color:#666">1</span>]
    <span style="color:#a2f;font-weight:bold">for</span> i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#666">2</span><span style="color:#666">:</span>length<span style="color:#666"></span>(x<span style="color:#666"></span>)
        s<span style="color:#666"></span>[i<span style="color:#666"></span>] <span style="color:#666">=</span> α<span style="color:#666"></span><span style="color:#666">*</span>x<span style="color:#666"></span>[i<span style="color:#666"></span>] <span style="color:#666">+</span> (<span style="color:#666">1</span><span style="color:#666">-</span>α<span style="color:#666"></span>)<span style="color:#666">*</span>s<span style="color:#666"></span>[i<span style="color:#666"></span><span style="color:#666">-</span><span style="color:#666">1</span>]
    <span style="color:#a2f;font-weight:bold">end</span>
    s<span style="color:#666"></span>
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>This would result in an approximately-exponential decay with timescale <code>1/α</code>.</p>

<p>Here, we want to implement this algorithm so that it can be used to
exponentially filter an array along any chosen dimension.  Once again,
the implementation is surprisingly simple:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">function</span> expfiltdim<span style="color:#666"></span>(x<span style="color:#666"></span>, dim<span style="color:#666"></span><span style="color:#666">:</span><span style="color:#666">:</span><span style="color:#0b0;font-weight:bold">Integer</span>, α<span style="color:#666"></span>)
    s<span style="color:#666"></span> <span style="color:#666">=</span> similar<span style="color:#666"></span>(x<span style="color:#666"></span>)
    Rpre<span style="color:#666"></span> <span style="color:#666">=</span> CartesianIndices<span style="color:#666"></span>(size<span style="color:#666"></span>(x<span style="color:#666"></span>)[<span style="color:#666">1</span><span style="color:#666">:</span>dim<span style="color:#666"></span><span style="color:#666">-</span><span style="color:#666">1</span>])
    Rpost<span style="color:#666"></span> <span style="color:#666">=</span> CartesianIndices<span style="color:#666"></span>(size<span style="color:#666"></span>(x<span style="color:#666"></span>)[dim<span style="color:#666"></span><span style="color:#666">+</span><span style="color:#666">1</span><span style="color:#666">:</span><span style="color:#a2f;font-weight:bold">end</span>])
    _expfilt!<span style="color:#666"></span>(s<span style="color:#666"></span>, x<span style="color:#666"></span>, α<span style="color:#666"></span>, Rpre<span style="color:#666"></span>, size<span style="color:#666"></span>(x<span style="color:#666"></span>, dim<span style="color:#666"></span>), Rpost<span style="color:#666"></span>)
<span style="color:#a2f;font-weight:bold">end</span>

<span style="color:#a2f;font-weight:bold">function</span> _expfilt!<span style="color:#666"></span>(s<span style="color:#666"></span>, x<span style="color:#666"></span>, α<span style="color:#666"></span>, Rpre<span style="color:#666"></span>, n<span style="color:#666"></span>, Rpost<span style="color:#666"></span>)
    <span style="color:#a2f;font-weight:bold">for</span> Ipost<span style="color:#666"></span> <span style="color:#a2f">in</span> Rpost<span style="color:#666"></span>
        <span style="color:#080;font-style:italic"># Initialize the first value along the filtered dimension</span>
        <span style="color:#a2f;font-weight:bold">for</span> Ipre<span style="color:#666"></span> <span style="color:#a2f">in</span> Rpre<span style="color:#666"></span>
            s<span style="color:#666"></span>[Ipre<span style="color:#666"></span>, <span style="color:#666">1</span>, Ipost<span style="color:#666"></span>] <span style="color:#666">=</span> x<span style="color:#666"></span>[Ipre<span style="color:#666"></span>, <span style="color:#666">1</span>, Ipost<span style="color:#666"></span>]
        <span style="color:#a2f;font-weight:bold">end</span>
        <span style="color:#080;font-style:italic"># Handle all other entries</span>
        <span style="color:#a2f;font-weight:bold">for</span> i<span style="color:#666"></span> <span style="color:#666">=</span> <span style="color:#666">2</span><span style="color:#666">:</span>n<span style="color:#666"></span>
            <span style="color:#a2f;font-weight:bold">for</span> Ipre<span style="color:#666"></span> <span style="color:#a2f">in</span> Rpre<span style="color:#666"></span>
                s<span style="color:#666"></span>[Ipre<span style="color:#666"></span>, i<span style="color:#666"></span>, Ipost<span style="color:#666"></span>] <span style="color:#666">=</span> α<span style="color:#666"></span><span style="color:#666">*</span>x<span style="color:#666"></span>[Ipre<span style="color:#666"></span>, i<span style="color:#666"></span>, Ipost<span style="color:#666"></span>] <span style="color:#666">+</span> (<span style="color:#666">1</span><span style="color:#666">-</span>α<span style="color:#666"></span>)<span style="color:#666">*</span>s<span style="color:#666"></span>[Ipre<span style="color:#666"></span>, i<span style="color:#666"></span><span style="color:#666">-</span><span style="color:#666">1</span>, Ipost<span style="color:#666"></span>]
            <span style="color:#a2f;font-weight:bold">end</span>
        <span style="color:#a2f;font-weight:bold">end</span>
    <span style="color:#a2f;font-weight:bold">end</span>
    s<span style="color:#666"></span>
<span style="color:#a2f;font-weight:bold">end</span></code></pre></div>

<p>Note once again the use of the function barrier technique.  In the
core algorithm (<code>_expfilt!</code>), our strategy is to use <em>two</em>
<code>CartesianIndex</code> iterators, <code>Ipre</code> and <code>Ipost</code>, where the first covers
dimensions <code>1:dim-1</code> and the second <code>dim+1:ndims(x)</code>; the filtering
dimension <code>dim</code> is handled separately by an integer-index <code>i</code>.
Because the filtering dimension is specified by an integer input,
there is no way to infer how many entries will be within each
index-tuple <code>Ipre</code> and <code>Ipost</code>.  Hence, we compute the <code>CartesianIndices</code>s in
the type-unstable portion of the algorithm, and then pass them as
arguments to the core routine <code>_expfilt!</code>.</p>

<p>What makes this implementation possible is the fact that we can index
<code>x</code> as <code>x[Ipre, i, Ipost]</code>.  Note that the total number of indexes
supplied is <code>(dim-1) + 1 + (ndims(x)-dim)</code>, which is just <code>ndims(x)</code>.
In general, you can supply any combination of integer and
<code>CartesianIndex</code> indexes when indexing an <code>AbstractArray</code> in Julia.</p>

<p>The <a href="https://github.com/timholy/AxisAlgorithms.jl">AxisAlgorithms</a>
package makes heavy use of tricks such as these, and in turn provides
core support for high-performance packages like
<a href="https://github.com/JuliaMath/Interpolations.jl">Interpolations</a> that
require multidimensional computation.</p>

<h1 id="additional-issues">Additional issues</h1>

<h2 id="cache-efficiency">Cache-efficiency</h2>

<p>It&rsquo;s worth noting one point that has thus far remained unstated: all
of the examples here are relatively <em>cache efficient</em>.  This is a key
property to observe when writing <a href="http://julialang.org/blog/2013/09/fast-numeric">efficient
code</a>.  In
particular, julia arrays are stored in first-to-last dimension order
(for matrices, &ldquo;column-major&rdquo; order), and hence you should nest
iterations from last-to-first dimensions.  For example, in the
filtering example above we were careful to iterate in the order</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia"><span style="color:#a2f;font-weight:bold">for</span> Ipost<span style="color:#666"></span> <span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>
    <span style="color:#a2f;font-weight:bold">for</span> i<span style="color:#666"></span> <span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>
        <span style="color:#a2f;font-weight:bold">for</span> Ipre<span style="color:#666"></span> <span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span>
            x<span style="color:#666"></span>[Ipre<span style="color:#666"></span>, i<span style="color:#666"></span>, Ipost<span style="color:#666"></span>] <span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span></code></pre></div>

<p>so that <code>x</code> would be traversed in memory-order.</p>

<h2 id="broadcasting">Broadcasting</h2>

<p><code>CartesianIndex</code>es are <em>not</em> broadcastable:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">julia<span style="color:#666"></span><span style="color:#666">&gt;</span> <span style="color:#a2f">I</span> <span style="color:#666">=</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">7</span>)
<span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">7</span>)

julia<span style="color:#666"></span><span style="color:#666">&gt;</span> <span style="color:#a2f">I</span> <span style="color:#666">.+</span> <span style="color:#666">1</span>
ERROR<span style="color:#666"></span><span style="color:#666">:</span> iteration<span style="color:#666"></span> is<span style="color:#666"></span> deliberately<span style="color:#666"></span> unsupported<span style="color:#666"></span> <span style="color:#a2f;font-weight:bold">for</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span><span style="color:#666">.</span> Use<span style="color:#666"></span> <span style="color:#b44">`</span><span style="color:#b44">I</span><span style="color:#b44">`</span> rather<span style="color:#666"></span> than<span style="color:#666"></span> <span style="color:#b44">`</span><span style="color:#b44">I</span><span style="color:#b44">.</span><span style="color:#b44">.</span><span style="color:#b44">.</span><span style="color:#b44">`</span>, or<span style="color:#666"></span> use<span style="color:#666"></span> <span style="color:#b44">`</span><span style="color:#b44">T</span><span style="color:#b44">u</span><span style="color:#b44">p</span><span style="color:#b44">l</span><span style="color:#b44">e</span><span style="color:#b44">(</span><span style="color:#b44">I</span><span style="color:#b44">)</span><span style="color:#b44">.</span><span style="color:#b44">.</span><span style="color:#b44">.</span><span style="color:#b44">`</span>
Stacktrace<span style="color:#666"></span><span style="color:#666">:</span>
 [<span style="color:#666">1</span>] error<span style="color:#666"></span>(<span style="color:#666">:</span><span style="color:#666">:</span>String<span style="color:#666"></span>) at<span style="color:#666"></span> <span style="color:#666">./</span>error<span style="color:#666"></span><span style="color:#666">.</span>jl<span style="color:#666"></span><span style="color:#666">:</span><span style="color:#666">33</span>
 [<span style="color:#666">2</span>] iterate<span style="color:#666"></span>(<span style="color:#666">:</span><span style="color:#666">:</span><span style="color:#0b0;font-weight:bold">CartesianIndex</span>{<span style="color:#666">2</span>}) at<span style="color:#666"></span> <span style="color:#666">./</span>multidimensional<span style="color:#666"></span><span style="color:#666">.</span>jl<span style="color:#666"></span><span style="color:#666">:</span><span style="color:#666">154</span>
<span style="color:#666">.</span><span style="color:#666">.</span><span style="color:#666">.</span></code></pre></div>

<p>When you want to perform broadcast arithmetic, just extract the underlying tuple:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">julia<span style="color:#666"></span><span style="color:#666">&gt;</span> <span style="color:#0b0;font-weight:bold">Tuple</span>(<span style="color:#a2f">I</span>) <span style="color:#666">.+</span> <span style="color:#666">1</span>
(<span style="color:#666">3</span>, <span style="color:#666">8</span>)</code></pre></div>

<p>If desired you can package this back up in a <code>CartesianIndex</code>, or just
use it directly (with splatting) for indexing.
The compiler optimizes all these operations away, so there is no actual
&ldquo;cost&rdquo; to constucting objects in this way.</p>

<p>Why is iteration disallowed? One reason is to support the following:</p>

<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-julia" data-lang="julia">julia<span style="color:#666"></span><span style="color:#666">&gt;</span> R<span style="color:#666"></span> <span style="color:#666">=</span> CartesianIndices<span style="color:#666"></span>((<span style="color:#666">1</span><span style="color:#666">:</span><span style="color:#666">3</span>, <span style="color:#666">1</span><span style="color:#666">:</span><span style="color:#666">3</span>))
<span style="color:#666">3</span>×3<span style="color:#666"></span> CartesianIndices<span style="color:#666"></span>{<span style="color:#666">2</span>,<span style="color:#0b0;font-weight:bold">Tuple</span>{<span style="color:#0b0;font-weight:bold">UnitRange</span>{<span style="color:#0b0;font-weight:bold">Int64</span>},<span style="color:#0b0;font-weight:bold">UnitRange</span>{<span style="color:#0b0;font-weight:bold">Int64</span>}}}<span style="color:#666">:</span>
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">1</span>, <span style="color:#666">1</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">1</span>, <span style="color:#666">2</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">1</span>, <span style="color:#666">3</span>)
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">1</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">2</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">3</span>)
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">1</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">2</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">3</span>)

julia<span style="color:#666"></span><span style="color:#666">&gt;</span> R<span style="color:#666"></span> <span style="color:#666">.+</span> <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">2</span>, <span style="color:#666">17</span>)
<span style="color:#666">3</span>×3<span style="color:#666"></span> CartesianIndices<span style="color:#666"></span>{<span style="color:#666">2</span>,<span style="color:#0b0;font-weight:bold">Tuple</span>{<span style="color:#0b0;font-weight:bold">UnitRange</span>{<span style="color:#0b0;font-weight:bold">Int64</span>},<span style="color:#0b0;font-weight:bold">UnitRange</span>{<span style="color:#0b0;font-weight:bold">Int64</span>}}}<span style="color:#666">:</span>
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">18</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">19</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">3</span>, <span style="color:#666">20</span>)
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">4</span>, <span style="color:#666">18</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">4</span>, <span style="color:#666">19</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">4</span>, <span style="color:#666">20</span>)
 <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">5</span>, <span style="color:#666">18</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">5</span>, <span style="color:#666">19</span>)  <span style="color:#0b0;font-weight:bold">CartesianIndex</span>(<span style="color:#666">5</span>, <span style="color:#666">20</span>)</code></pre></div>

<p>The underlying idea is that <code>CartesianIndex(2, 17)</code> needs to act, everywhere,
like a pair of scalar indexes; consequently, a <code>CartesianIndex</code> has to be
viewed as a single (scalar) entity, rather than as a container in its own right.</p>

<h1 id="summary">Summary</h1>

<p>As is hopefully clear by now, much of the pain of writing generic
multidimensional algorithms is eliminated by Julia&rsquo;s elegant
iterators.  The examples here just scratch the surface, but the
underlying principles are very simple; it is hoped that these
examples will make it easier to write your own algorithms.</p>


  </div>

  

  </div>
  </div>
  </div>

  <br />

  


  <head>
  <meta name="description" content="We thank our contributors, donators, and Fastly for their support in keeping the Julia Language going. Donate here to help pay for Julia's needs."/>
</head>

<footer class="container-fluid footer-copy">
    <div class="container">
      <div class="row">
        <div class="col-md-10 py-2">
          <p>
            We thank <a style="color: #7a95dd" href="https://www.fastly.com">Fastly</a> for their generous infrastructure support. Donations help pay for community resources such as CI, Discourse, workshops, travel, JuliaCon, and other such needs.
          </p>
          <p>
            ©2020 JuliaLang.org contributors. The website content uses the <a style="color: #7a95dd" href="https://github.com/JuliaLang/www.julialang.org/blob/master/LICENSE.md">MIT license</a>.
          </p>
        </div>
        <div class="col-md-2 py-2">
          <a class="btn btn-success" href="https://numfocus.org/donate-to-julia">Donate</a>
        </div>
      </div>
    </div>
</footer>


  <script src="../../../../v2/js/jquery.min.js"></script>
<script src="../../../../v2/js/bootstrap.min.js"></script>
<script src="../../../../v2/js/platform.js"></script>
<script src="../../../../v2/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script async defer src="https://buttons.github.io/buttons.js"></script>

</body>

</html>
